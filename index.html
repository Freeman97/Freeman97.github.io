<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Freeman&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Self-talking of a noob">
<meta property="og:type" content="website">
<meta property="og:title" content="Freeman&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Freeman&#39;s Blog">
<meta property="og:description" content="Self-talking of a noob">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Freeman&#39;s Blog">
<meta name="twitter:description" content="Self-talking of a noob">
  
    <link rel="alternate" href="/atom.xml" title="Freeman&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/image/favicon.ico">
  
  
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/prism-okaidia.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Freeman&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">一个菜鸡心血来潮搭建的个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-算法题中的数学类型题归集" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/09/07/算法题中的数学类型题归集/" class="article-date">
  <time datetime="2020-09-07T03:13:17.000Z" itemprop="datePublished">2020-09-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构与算法/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/09/07/算法题中的数学类型题归集/">算法题中的数学类型题归集</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>非科班鶸遇到数学题总是比较头疼，于是做一点整理</strong></p>
        
          <p class="article-more-link">
            <a href="/2020/09/07/算法题中的数学类型题归集/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/09/07/算法题中的数学类型题归集/" data-id="cketor9hd00040gvhb7h437ua" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-剑指offer题解" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/11/剑指offer题解/" class="article-date">
  <time datetime="2020-08-11T12:39:49.000Z" itemprop="datePublished">2020-08-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构与算法/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/11/剑指offer题解/">剑指offer题解（一） - JZ1 ~ JZ10</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>二刷一下剑指offer的题顺便记录一下题解，日后再做分类整理（咕咕咕）</strong><br><strong>题目顺序和标号按照牛客网(<a href="https://www.nowcoder.com/ta/coding-interviews)，本文持续增量更新（" target="_blank" rel="noopener">https://www.nowcoder.com/ta/coding-interviews)，本文持续增量更新（</a></strong><br>
        
          </p><p class="article-more-link">
            <a href="/2020/08/11/剑指offer题解/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/11/剑指offer题解/" data-id="cketor9i900150gvhkxvtlo6e" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java学习-泛型与反射" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/08/Java学习-泛型与反射/" class="article-date">
  <time datetime="2020-08-08T08:44:16.000Z" itemprop="datePublished">2020-08-08</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/语言学习/">语言学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/08/Java学习-泛型与反射/">Java学习 - 泛型与反射</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h1><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p><code>Class</code>类用于保存及获取对象的运行时类型信息。程序在运行时对自身信息（元数据）进行检测<br>进而修改自己的行为被称为反射。<br><code>Object</code>类中的<code>getClass()</code>方法返回一个<code>Class</code>类型的实例。<code>Class</code>的静态方法<code>forName()</code>可以根据类名获得对应<code>Class</code>对象，注意要为这个方法提供异常处理。如果有一个<code>Class</code>类型的对象，可以使用<code>getConstructor()</code>方法得到一个<code>Constructor</code>类型的对象，然后使用<code>newInstance()</code>方法构造一个实例。<br>JVM不会一次性把所有用到的类全部加载到内存，它首先加载包含<code>main</code>方法的类，然后加载该类所需的所有类，以此类推。可以在运行期根据条件利用<code>Class.forName()</code>来手动强制加载其他类。</p>
<h2 id="利用反射分析类"><a href="#利用反射分析类" class="headerlink" title="利用反射分析类"></a>利用反射分析类</h2><h3 id="访问字段-Field"><a href="#访问字段-Field" class="headerlink" title="访问字段(Field)"></a>访问字段(Field)</h3><p>首先，可以通过<code>Class</code>实例获取字段信息</p>
<ul>
<li><code>Field getField(name)</code> 根据字段名称获得public的field</li>
<li><code>Field getDeclaredField(name)</code> 根据字段名称获得field</li>
<li><code>Field[] getFields()</code> 获取所有public的field</li>
<li><code>Field[] getDeclaredFields()</code> 获取所有field<br><code>Field</code>对象包含了一个字段的所有信息</li>
<li><code>getName()</code> 返回字段名</li>
<li><code>getType()</code> 返回字段类型（一个<code>Class</code>实例）</li>
<li><code>getModifiers()</code> 返回字段修饰符，每个bit表示不同的涵义，可以使用<code>Modifier</code>类的一些静态方法对返回的值进行解析。<br>获得字段的<code>Field</code>实例后我们还可以获取或设置一个实例该字段的值。</li>
<li><code>get()</code> 返回某一对象中这个<code>Field</code>描述的字段值</li>
<li><code>set()</code> 将字段值设为一个新值<br>对于<code>private</code>字段进行如上的操作会得到一个<code>IllegalAccessException</code>，因此我们可以先试图查询这个字段的可访问性，如有必要可以对其进行修改</li>
<li><code>void setAccessible(boolean flag)</code></li>
<li><code>boolean trySetAccessible(boolean flag)</code> （Java 9+）</li>
<li><code>boolean isAccessible()</code></li>
<li><code>static void setAccessble(AccessibleObject[] array, boolean flag)</code></li>
</ul>
<h3 id="调用方法-Method"><a href="#调用方法-Method" class="headerlink" title="调用方法(Method)"></a>调用方法(Method)</h3><p>可以通过<code>Class</code>实例获取<code>Method</code>信息</p>
<ul>
<li><code>Method getMethod(name, Class...)</code> 获取某个public的method</li>
<li><code>Method getDeclaredMethod(name, Class...)</code> 获取某个method</li>
<li><code>Method[] getMethods()</code></li>
<li><code>Method[] getDeclaredMethods()</code><br><code>Method</code>对象包含一个方法的所有信息</li>
<li><code>getName()</code> 方法名</li>
<li><code>getReturnType()</code> 返回值，返回的是<code>Class</code>实例</li>
<li><code>getParameterTypes()</code> 方法的参数类型，是一个<code>Class</code>数组</li>
<li><code>getModifiers()</code> 方法的修饰符。类似于<code>Field</code>的修饰符。<br>可以通过<code>Method</code>对象的<code>invoke</code>方法来反射调用方法。</li>
<li><code>public Object invoke(Object implicitParameter, Object[] explicitParameters)</code> 反射调用方法，第一个参数是对象实例，即在哪个实例上调用该方法。调用静态方法时第一个参数传入<code>null</code><br>和<code>Field</code>类似，对于非public方法直接调用将得到<code>IllegalAccessException</code>。查询和修改方法的可访问性的方式与<code>Field</code>类似。<br>使用反射调用方法时遵循多态原则，即总是调用实际类型的覆写方法（如果存在）。</li>
</ul>
<h3 id="调用构造方法-Constructor"><a href="#调用构造方法-Constructor" class="headerlink" title="调用构造方法(Constructor)"></a>调用构造方法(Constructor)</h3><p>可以通过<code>Class</code>实例获取<code>Constructor</code>信息</p>
<ul>
<li><code>getConstructor(Class...)</code></li>
<li><code>getDeclaredConstructor(Class...)</code></li>
<li><code>getConstructors()</code></li>
<li><code>getDeclaredConstructors()</code><br>通过<code>Constructor</code>实例可以利用<code>newInstance()</code>创建一个实例对象</li>
<li><code>newInstance(Object...parameters)</code></li>
</ul>
<h3 id="编写泛型数组代码（Todo）"><a href="#编写泛型数组代码（Todo）" class="headerlink" title="编写泛型数组代码（Todo）"></a>编写泛型数组代码（Todo）</h3><h3 id="动态代理（Todo）"><a href="#动态代理（Todo）" class="headerlink" title="动态代理（Todo）"></a>动态代理（Todo）</h3><h1 id="泛型类的定义"><a href="#泛型类的定义" class="headerlink" title="泛型类的定义"></a>泛型类的定义</h1><pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ClassName<t, u=""> {
    private T member1;
    private U member2;

    public T method1() {...}

    public void method2(T argument1) {...}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></t,></code></pre>
<h1 id="泛型方法的定义"><a href="#泛型方法的定义" class="headerlink" title="泛型方法的定义"></a>泛型方法的定义</h1><pre class="line-numbers language-lang-java"><code class="language-lang-java">class ClassName {
    public <t> T method(T argument) {...}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></t></code></pre>
<p>泛型方法的类型推导是可能出错的（？）</p>
<h1 id="对类型变量进行限定"><a href="#对类型变量进行限定" class="headerlink" title="对类型变量进行限定"></a>对类型变量进行限定</h1><p>可以限制传入的类型必须是某个类型的子类或必须实现某些接口。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">class ClassName {
    public <t extends="" superclass="" &="" interface1="" interface2=""> T method() {...}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></t></code></pre>
<p>可以根据需要声明多个限定，但最多有一个限定可以是类，且类作为限定时必须是限定列表中的第一个限定。</p>
<h1 id="泛型代码与虚拟机"><a href="#泛型代码与虚拟机" class="headerlink" title="泛型代码与虚拟机"></a>泛型代码与虚拟机</h1><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>定义一个泛型类型时，都会自动提供一个相应的原始类型(raw type)。这个原始类型的名字就是去掉类型参数之后的泛型类型名。类型变量会被擦除(erased)，并替换为限定类型。对于无限定的变量则替换为Object。对于泛型类</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ClassName<t> {
    private T member1;

    public T method1() {...}

    public void method2(T argument1) {...}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></t></code></pre>
<p>其原始类型为</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ClassName {
    private Object member1;

    public Object method1() {...}

    public void method2(Object argument1) {...}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>程序中包含不同类型的<code>ClassName</code>，被擦除类型后都会变成<code>ClassName</code>的原始类型。与C++的模板相比，C++会为每个模板的实例化产生不同的类型。</p>
<p>而对于给出限定的泛型类，其原始类型会使用第一个限定来替换类型变量。对于泛型类</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ClassName<t extends="" interface1="" &="" interface2=""> {
    private T member;

    public ClassName(T argument) {...}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></t></code></pre>
<p>其原始类型将为</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ClassName {
    private Interface1 member;

    public ClassName(Interface1 argument) {...}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果有必要，编译器可能会在此时插入强制类型转换。为提高效率，应将没有方法的接口放在限定列表的末尾。</p>
<h2 id="转换泛型表达式"><a href="#转换泛型表达式" class="headerlink" title="转换泛型表达式"></a>转换泛型表达式</h2><p>调用泛型方法时，如果擦除了返回类型，编译器会插入强制类型转换。例如，对于如下的泛型类</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class ClassName<t> {
    private T member;
    public T getMember() {
        return this.member;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></t></code></pre>
<p>考虑以下语句序列</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">ClassName<classname2> a = ...;
ClassName2 b = a.getMember();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></classname2></code></pre>
<p>原始类型中的<code>getMember()</code>方法返回值类型被擦除，返回类型为<code>Object</code>。此时第二行语句会发生从<code>Object</code>到<code>ClassName2</code>的强制类型转换（在结果字节码中）。</p>
<h2 id="转换泛型方法"><a href="#转换泛型方法" class="headerlink" title="转换泛型方法"></a>转换泛型方法</h2><p>继承传入类型参数的泛型类得到的子类，在重写父类的同名方法时可能会遇到类型擦除与多态性相冲突的情况。编译器会合成桥方法(bridge method)来保证多态性。（有待补充）</p>
<h1 id="Java泛型的限制与局限性"><a href="#Java泛型的限制与局限性" class="headerlink" title="Java泛型的限制与局限性"></a>Java泛型的限制与局限性</h1><h2 id="不能用基本类型实例化类型参数（无法类型擦除）"><a href="#不能用基本类型实例化类型参数（无法类型擦除）" class="headerlink" title="不能用基本类型实例化类型参数（无法类型擦除）"></a>不能用基本类型实例化类型参数（无法类型擦除）</h2><h2 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h2><p>对于所有泛型类，所有的类型查询只会产生原始类型。对于<code>ClassName&lt;T&gt;</code>，所有类型查询(<code>instanceof</code>, 强制类型转换)只能判断变量是否为任意类型的一个<code>ClassName</code>。同时，<code>getClass</code>方法也总是返回原始类型。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">ClassName1<classname2> a = ...;
// 只返回ClassName1.class
a.getClass();
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></classname2></code></pre>
<h2 id="不能创建参数化类型的数组"><a href="#不能创建参数化类型的数组" class="headerlink" title="不能创建参数化类型的数组"></a>不能创建参数化类型的数组</h2><p>Java的数组不是泛型容器，在运行时会持有它的元素类型信息，如果试图存储其它类型的元素会先尝试类型转换，失败则会抛出一个ArrayStoreException异常。<br>对于示例类</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">// 这是一个后续各个例子都可能使用的类
class Pair<t> {
    private T first;
    private T second;

    public Pair(T f, T s) {
        this.first = f;
        this.second = s;
    }

    public T getFirst() {
        return this.first;
    }

    public T getSecond() {
        return this.second;
    }

    public void setFirst(T f) {
        this.first = f;
    }

    public void setSecond(T s) {
        this.second = s;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></t></code></pre>
<p>尝试定义这样一个数组</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">var table = new Pair<string>[10];
// 事实上无法编译通过
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></string></code></pre>
<p>如果能够编译通过，<code>table</code>的类型应为<code>Pair[]</code>。对于泛型类型，类型擦除会让数组的元素类型检查失效。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">table[0] = new Pair<othertype>();
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></othertype></code></pre>
<p>因此不允许创建参数化类型的数组。但是声明类型为<code>Pair&lt;String&gt;[]</code>的变量依然是合法的。<br>声明通配类型的数组是可以编译通过的。声明后可以对其进行强制类型转换，但这是不安全的。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">var table1 = (Pair<string>[]) new Pair<?>[10]; // 可以通过
table1[0] = new Pair<integer>(1, 1); // 按Java Core I中的大意写出的代码，但是直接报了类型转换错误，无法编译通过

var table2 = new Pair<?>[10];
table2[0] = new Pair<integer(1, 1)="">;
System.out.println(((Pair<string>[]) table2)[0].getFirst()); // 在调用getFirst()前对table2进行强制类型转换，可以编译通过，但是运行时会得到一个ClassCastException异常
// 问题: 上述table2的例子是否算是heap pollution的一个例子?
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></string></integer(1,></integer></string></code></pre>
<p>总之，如果有收集参数化类型对象的需求，使用泛型容器（如用ArrayList代替数组）更简单有效。</p>
<h2 id="Varargs警告"><a href="#Varargs警告" class="headerlink" title="Varargs警告"></a>Varargs警告</h2><p>Java不支持泛型类型的数组，但是在某种场合下这个限制会得到放松：向参数个数可变的方法传递泛型类型的实例。考虑以下代码</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Main {
    public static void main(String[] args) {
        Collection<pair<string>> table = new ArrayList<pair<string>>();
        Pair<string> pair1 = new Pair<string>("1", "2");
        Pair<string> pair2 = new Pair<string>("3", "4");
        ClassName.addAll(table, pair1, pair2);
    }
}

class ClassName {
    public static <t> void addAll(Collection<t> coll, T...ts) {
        // var type = ts.getClass();
        for(T t: ts) coll.add(t);
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></t></t></string></string></string></string></pair<string></pair<string></code></pre>
<p>为了调用<code>addAll()</code>，JVM必须建立一个<code>Pair&lt;String&gt;</code>数组。实际上使用debug可以发现参数ts的类型为<code>Pair[]</code>（已经经历了类型擦除）。这种情况下，不会得到错误，而只会在调用<code>addAll()</code>的地方得到警告<code>Type safety: A generic array of Pair&lt;String&gt; is created for a varargs parameter</code>。可以使用<code>@SafeVarargs</code>注解来消除创建泛型数组的有关限制，但要注意这始终是一个危险的操作，下面的代码给出了一个例子。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Main {
    public static void main(String[] args) {
        Collection<pair<string>> table = new ArrayList<pair<string>>();
        Pair<string> pair1 = new Pair<string>("1", "2");
        Pair<string> pair2 = new Pair<string>("3", "4");
        Pair<string> pair3 = (Pair<string>)(Object)new Pair<integer>(5, 6);
        ClassName.addAll(table, pair1, pair2, pair3);
        try {
            // BOOM!
            String omg = ((ArrayList<pair<string>>) table).get(2).getFirst();
        } catch (ClassCastException e) {
            System.out.println("BOOM!");
        }
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></pair<string></integer></string></string></string></string></string></string></pair<string></pair<string></code></pre>
<p>上述代码还会在定义<code>addAll()</code>的地方得到警告<code>Type safety: Potential heap pollution via varargs parameter ts</code>。Heap pollution指的是一种特殊的引用（references），这种引用持有的类型并不是它所指向的对象的超类。</p>
<h2 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h2><p>即对于<code>Pair&lt;T&gt;</code>，不能实例化<code>T</code>。换言之这样的构造器是非法的</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">class Pair<t> {
    ...
    public Pair() {
        first = new T();
        second = new T();
    }
} // ERROR!
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></t></code></pre>
<p>解决方法：</p>
<ol>
<li>让调用者提供一个构造器表达式（Java 8+）<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static <t> Pair<t> makePair(Supplier<t> constr) {
    return new Pair<>(constr.get(), constr.get());
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></t></t></t></code></pre>
其中<code>Supplier&lt;T&gt;</code>为一个函数式接口，表示一个无参数且返回类型为<code>T</code>的函数。</li>
<li>通过反射调用<code>Constructor.newInstance</code>方法来构造泛型对象（？）<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static <t> Pair<t> makePair(Class<t> cl) {
    try {
        return new Pair<>(cl.getConstructor().newInstance(), cl.getConstructor().newInstance());
    } catch (Exception e) {
        return null;
    }
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></t></t></t></code></pre>
</li>
</ol>
<h2 id="不能构造泛型数组"><a href="#不能构造泛型数组" class="headerlink" title="不能构造泛型数组"></a>不能构造泛型数组</h2><p>与“不能创建参数化类型的数组”相似。解决方法：</p>
<ol>
<li>让用户提供一个数组构造器表达式（Java 8+）<pre class="line-numbers language-lang-java"><code class="language-lang-java">public static <t extends="" comparable=""> T[] minmax(IntFunction<t[]> constr, T...a) {
    T[] result = constr.apply(2);
    ...
}
...
//调用
String[] res = ArrayAlg.minmax(String[]::new, "abc", "def", "ghi");
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></t[]></t></code></pre>
</li>
<li>利用反射调用<code>Array.newInstance</code><pre class="line-numbers language-lang-java"><code class="language-lang-java">public static <t extends="" comparable=""> T[] minmax(T...a) {
    var result = (T[]) Array.newInstance(a.getClass.getComponentType(), 2);
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></t></code></pre>
</li>
</ol>
<h2 id="泛型类的静态上下文中类型变量无效"><a href="#泛型类的静态上下文中类型变量无效" class="headerlink" title="泛型类的静态上下文中类型变量无效"></a>泛型类的静态上下文中类型变量无效</h2><p>不能在静态字段或方法中引用类型变量。</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">public class Singleton<t> {
    private static T singleInstance; // ERROR (这个类以不同类型实例化两次不就出事了吗)

    public static T getSingleInstance() {
        ...
    } // ERROR
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></t></code></pre>
<h2 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h2><p>既不能抛出也不能捕获泛型类的对象，实际上泛型类无法扩展<code>Throwable</code>。<code>catch</code>子句中不能使用类型变量。</p>
<h2 id="可以取消对检查型异常的检查（Todo）"><a href="#可以取消对检查型异常的检查（Todo）" class="headerlink" title="可以取消对检查型异常的检查（Todo）"></a>可以取消对检查型异常的检查（Todo）</h2><h2 id="注意类型擦除后的冲突（Todo）"><a href="#注意类型擦除后的冲突（Todo）" class="headerlink" title="注意类型擦除后的冲突（Todo）"></a>注意类型擦除后的冲突（Todo）</h2><h1 id="泛型类型的继承规则"><a href="#泛型类型的继承规则" class="headerlink" title="泛型类型的继承规则"></a>泛型类型的继承规则</h1><p>考虑一个类<code>Class</code>及其子类<code>SubClass</code>。有如下的继承规则：</p>
<ol>
<li><code>ArrayList&lt;Class&gt;</code>继承了<code>ArrayList</code>（原始类型），实现了<code>List&lt;Class&gt;</code></li>
<li><code>ArrayList&lt;SubClass&gt;</code>继承了<code>ArrayList</code>（原始类型），实现了<code>List&lt;SubClass&gt;</code></li>
<li><code>List&lt;Class&gt;</code>继承了<code>List</code>（原始类型）</li>
<li><code>List&lt;SubClass&gt;</code>继承了<code>List</code>（原始类型）</li>
<li><code>ArrayList</code>（原始类型）实现了<code>List</code>（原始类型）</li>
<li><code>ArrayList&lt;Class&gt;</code>和<code>ArrayList&lt;SubClass&gt;</code>没有关系</li>
<li><code>List&lt;Class&gt;</code>和<code>List&lt;SubClass&gt;</code>没有关系</li>
</ol>
<h1 id="通配符类型"><a href="#通配符类型" class="headerlink" title="通配符类型"></a>通配符类型</h1><p>首先给出三个类及其继承关系：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">class SuperClass {...}
class SubClass extends SuperClass {...}
class SubSubClass extends SubClass {...}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>通配符类型允许类型参数发生变化。<code>Pair&lt;? extends SuperClass&gt;</code>表示任何泛型<code>Pair</code>类型，其类型参数是<code>SuperClass</code>的子类。若<code>SubClass</code>是<code>SuperClass</code>的子类，那么<code>Pair&lt;SuperClass&gt;</code>与<code>Pair&lt;SubClass&gt;</code>都是<code>Pair&lt;? extends SuperClass</code>的子类，而<code>Pair&lt;? extends SuperClass&gt;</code>是<code>Pair</code>（原始类型）的子类。</p>
<h2 id="超类型限定"><a href="#超类型限定" class="headerlink" title="超类型限定"></a>超类型限定</h2><p>通配符<code>? super ClassName</code>限制为<code>ClassName</code>的所有超类型。稍微有点绕，举个例子进行说明:对于<code>Pair&lt;? super SubClass&gt;</code>而言，有如下方法：</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">void setFirst(? super SubClass) {...}
? super SubClass getFirst() {...}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>由此可见，编译器不知道<code>setFirst</code>的具体类型（参数类型是<code>SubClass</code>的某个超类，这个超类及其子类才能作为参数传入，那么这个超类是哪一个呢？是<code>SuperClass</code>吗？还是<code>Object</code>？），因此无法接受<code>SuperClass</code>类型或<code>Object</code>类型的方法调用。而<code>SubClass</code>的子类型（如<code>SubSubClass</code>）对象或是<code>SubClass</code>类型的对象则可以作为参数传入。另外，如果调用<code>getFirst</code>，则不能保证返回值的类型（返回值类型是<code>SubClass</code>的某个超类，类型为这个超类及其超类的引用才能托管<code>getFirst</code>的返回值，然而这个超类具体是哪个同样无从得知），只能把返回值赋给一个<code>Object</code>。<br>对于超类型限定的继承关系，<code>Pair&lt;SuperClass&gt;</code>以及<code>Pair&lt;Object&gt;</code>是<code>Pair&lt;? super SubClass&gt;</code>的子类，而<code>Pair&lt;? super Manager&gt;</code>为<code>Pair&lt;?&gt;</code>的子类。</p>
<h2 id="无限定通配符"><a href="#无限定通配符" class="headerlink" title="无限定通配符"></a>无限定通配符</h2><p>例如<code>Pair&lt;?&gt;</code>，它有如下方法</p>
<pre class="line-numbers language-lang-java"><code class="language-lang-java">? getFirst()
void setFirst(?)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>getFirst</code>的返回值只能赋给一个<code>Object</code>，<code>setFirst</code>无法被调用。</p>
<h2 id="通配符捕获（Todo）"><a href="#通配符捕获（Todo）" class="headerlink" title="通配符捕获（Todo）"></a>通配符捕获（Todo）</h2><h2 id="通过反射分析泛型类信息（Todo）"><a href="#通过反射分析泛型类信息（Todo）" class="headerlink" title="通过反射分析泛型类信息（Todo）"></a>通过反射分析泛型类信息（Todo）</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/08/Java学习-泛型与反射/" data-id="cketor9i700140gvhuskkxgkt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/反射/">反射</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/泛型/">泛型</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-Weekly-Contest-129-题解" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/25/LeetCode-Weekly-Contest-129-题解/" class="article-date">
  <time datetime="2019-03-24T16:00:47.000Z" itemprop="datePublished">2019-03-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构与算法/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/25/LeetCode-Weekly-Contest-129-题解/">LeetCode-Weekly-Contest-129-题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>部分问题的题解是自己在比赛时实现的，有些题解的效率并不高，有些题解可能只是因为测试用例太弱而勉强AC，如果有人看到希望能够赐教。</strong><br><strong>所有题目都使用C++作答</strong><br>
        
          </p><p class="article-more-link">
            <a href="/2019/03/25/LeetCode-Weekly-Contest-129-题解/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/25/LeetCode-Weekly-Contest-129-题解/" data-id="cketor9h200000gvhk0kj94qy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KMP/">KMP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态规划/">动态规划</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-Weekly-Contest-128-题解" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/18/LeetCode-Weekly-Contest-128-题解/" class="article-date">
  <time datetime="2019-03-18T06:46:58.000Z" itemprop="datePublished">2019-03-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构与算法/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/18/LeetCode-Weekly-Contest-128-题解/">LeetCode-Weekly-Contest-128-题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>部分问题的题解是自己在比赛时实现的，有些题解的效率并不高，有些题解可能只是因为测试用例太弱而勉强AC，如果有人看到希望能够赐教。</strong><br><strong>所有题目都使用C++作答</strong><br><strong>Q4由于本人太鶸还没搞懂，搞懂了一定更新一定不鸽！</strong><br>
        
          </p><p class="article-more-link">
            <a href="/2019/03/18/LeetCode-Weekly-Contest-128-题解/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/18/LeetCode-Weekly-Contest-128-题解/" data-id="cketor9h800010gvhoh7rd5pi" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态规划/">动态规划</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-LeetCode-Weekly-Contest-111-题解" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/21/LeetCode-Weekly-Contest-111-题解/" class="article-date">
  <time datetime="2018-11-20T16:00:00.000Z" itemprop="datePublished">2018-11-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/数据结构与算法/">数据结构与算法</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/21/LeetCode-Weekly-Contest-111-题解/">LeetCode Weekly Contest #111 题解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>部分问题的题解是自己在比赛时实现的，有些题解的效率并不高，有些题解可能只是因为测试用例太弱而勉强AC，如果有人看到希望能够赐教。</strong><br><strong>所有题目都使用C++作答</strong><br>
        
          </p><p class="article-more-link">
            <a href="/2018/11/21/LeetCode-Weekly-Contest-111-题解/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/11/21/LeetCode-Weekly-Contest-111-题解/" data-id="cketor9ib00180gvhlsvtjlqf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/减治法/">减治法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/动态规划/">动态规划</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/10/26/hello-world/" class="article-date">
  <time datetime="2018-10-25T16:00:00.000Z" itemprop="datePublished">2018-10-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Diary/">Diary</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/10/26/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>这是一个心血来潮搭建的个人博客。</strong><br>一直在零零碎碎地学习一些东西，之前完全没有把自己的学习系统地整理一遍的习惯。以搭个人博客为契机，今后将自己学习的各方面知识整理到这里吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/10/26/hello-world/" data-id="cketor9hf00050gvh6thph8xr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nonsense/">nonsense</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/self-taking/">self-taking</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Diary/">Diary</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/语言学习/">语言学习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Algorithm/">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KMP/">KMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode/">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nonsense/">nonsense</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/self-taking/">self-taking</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/减治法/">减治法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/反射/">反射</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/泛型/">泛型</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Algorithm/" style="font-size: 20px;">Algorithm</a> <a href="/tags/C/" style="font-size: 16.67px;">C++</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/KMP/" style="font-size: 10px;">KMP</a> <a href="/tags/LeetCode/" style="font-size: 13.33px;">LeetCode</a> <a href="/tags/nonsense/" style="font-size: 10px;">nonsense</a> <a href="/tags/self-taking/" style="font-size: 10px;">self-taking</a> <a href="/tags/减治法/" style="font-size: 10px;">减治法</a> <a href="/tags/动态规划/" style="font-size: 13.33px;">动态规划</a> <a href="/tags/反射/" style="font-size: 10px;">反射</a> <a href="/tags/泛型/" style="font-size: 10px;">泛型</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">九月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/09/07/算法题中的数学类型题归集/">算法题中的数学类型题归集</a>
          </li>
        
          <li>
            <a href="/2020/08/11/剑指offer题解/">剑指offer题解（一） - JZ1 ~ JZ10</a>
          </li>
        
          <li>
            <a href="/2020/08/08/Java学习-泛型与反射/">Java学习 - 泛型与反射</a>
          </li>
        
          <li>
            <a href="/2019/03/25/LeetCode-Weekly-Contest-129-题解/">LeetCode-Weekly-Contest-129-题解</a>
          </li>
        
          <li>
            <a href="/2019/03/18/LeetCode-Weekly-Contest-128-题解/">LeetCode-Weekly-Contest-128-题解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 <a href="https://github.com/Freeman97" target="_blank">Freeman Huang</a><br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>